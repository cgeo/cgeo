package cgeo.geocaching.utils;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.regex.Pattern;

import org.apache.commons.lang3.StringUtils;

/**
 * This parser tries to get the start time of events. Since there is no GPX field for that, we have to guess from plain
 * text.
 */
public class EventTimeParser {
    /**
     * event time format embedded into cache descriptions as generated by https://gcffm.de/eventstandard.html
     */
    private static final SynchronizedDateFormat EVENT_DATE_FORMAT = new SynchronizedDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.US); // 2010-04-20T07:00:00

    private static final List<Pattern> EVENT_TIME_PATTERNS = new ArrayList<>();

    private static final int UNKNOWN = -1;

    private EventTimeParser() {
        // utility class
    }

    public static int guessEventTimeMinutes(final String searchText) {
        final int eventTimeStandardFormat = getEventTimeStandardFormat(searchText);
        if (eventTimeStandardFormat != UNKNOWN) {
            return eventTimeStandardFormat;
        }

        int start = UNKNOWN;
        int eventTimeMinutes = UNKNOWN;
        for (final Pattern pattern : getEventTimePatterns()) {
            final MatcherWrapper matcher = new MatcherWrapper(pattern, searchText);
            while (matcher.find()) {
                try {
                    final int hours = Integer.parseInt(matcher.group(1));
                    int minutes = 0;
                    if (matcher.groupCount() >= 2 && StringUtils.isNotEmpty(matcher.group(2))) {
                        minutes = Integer.parseInt(matcher.group(2));
                    }
                    if (hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60 && (eventTimeMinutes == -1 || matcher.start() < start)) {
                        eventTimeMinutes = hours * 60 + minutes;
                        start = matcher.start();
                    }
                } catch (final NumberFormatException ignored) {
                    // cannot happen, but static code analysis doesn't know
                }
            }
        }
        return eventTimeMinutes;
    }

    public static int[] getEventTimesFromGcShortDesc(final String searchText) {
        final int[] times = new int[] { -1, -1 };
        final Pattern gcShortDescPattern = Pattern.compile("^<b>\\d{2} [A-Za-z]+ \\d{4}, (\\d{2}):(\\d{2}) - (\\d{2}):(\\d{2})</b>$");
        final MatcherWrapper matcher = new MatcherWrapper(gcShortDescPattern, searchText);
        if (matcher.matches()) {
            times[0] = Integer.parseInt(matcher.group(1)) * 60 + Integer.parseInt(matcher.group(2));
            times[1] = Integer.parseInt(matcher.group(3)) * 60 + Integer.parseInt(matcher.group(4));
        }
        return times;
    }

    /**
     * find a text matching https://gcffm.de/eventstandard.html
     */
    private static int getEventTimeStandardFormat(final String searchText) {
        final String eventStandardText = StringUtils.substringBetween(searchText, "dtstart_", "\"");
        if (eventStandardText != null) {
            try {
                final Date eventStandardDate = EVENT_DATE_FORMAT.parse(eventStandardText);
                final Calendar calendar = Calendar.getInstance();
                calendar.setTime(eventStandardDate);
                return calendar.get(Calendar.HOUR_OF_DAY) * 60 + calendar.get(Calendar.MINUTE);
            } catch (final ParseException e) {
                Log.e("Cannot parse event time standard format", e);
            }
        }
        return UNKNOWN;
    }

    /**
     * lazily initialize all the date formats
     */
    private static List<Pattern> getEventTimePatterns() {
        if (EVENT_TIME_PATTERNS.isEmpty()) {
            final String hourLocalized = CgeoApplication.getInstance().getString(R.string.cache_time_full_hours);

            // 12:34
            EVENT_TIME_PATTERNS.add(Pattern.compile("\\b(\\d{1,2})\\:(\\d\\d)\\b"));
            if (StringUtils.isNotBlank(hourLocalized)) {
                // 12:34o'clock
                EVENT_TIME_PATTERNS.add(Pattern.compile("\\b(\\d{1,2})\\:(\\d\\d)" + Pattern.quote(hourLocalized), Pattern.CASE_INSENSITIVE));
                // 17 - 20 o'clock
                EVENT_TIME_PATTERNS.add(Pattern.compile("\\b(\\d{1,2})(?:\\.00)?" + "\\s*(?:-|[a-z]+)\\s?" + "(?:\\d{1,2})(?:\\.00)?" + "\\s?" + Pattern.quote(hourLocalized), Pattern.CASE_INSENSITIVE));
                // 12 o'clock, 12.00 o'clock
                EVENT_TIME_PATTERNS.add(Pattern.compile("\\b(\\d{1,2})(?:\\.(00|15|30|45))?\\s?" + Pattern.quote(hourLocalized), Pattern.CASE_INSENSITIVE));
            }
        }
        return EVENT_TIME_PATTERNS;
    }

}
